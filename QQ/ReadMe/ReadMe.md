服务器架构:
TCP+多线程/线程池 优点:简单(来一个客户端提供一个线程) 缺点:线程太多,影响服务器性能
UDP 优点:简单 支持高并发 循环服务器 缺点:协议有缺点,不安全,容易丢包(我们不希望丢包)

多路复用: 
select:支持的文件描述符数量有限 效率低,每次都要自己挨个去遍历一遍那个集合,这一圈下来很浪费时间
pool:其实就是在select的基础上升级了链表,所以理论上他支持的文件描述符是无限的,
但是链表的结构特性就是他是一个节点一个节点链上去的,你很难像数组那样立刻就能找到,
找一个节点他最坏的情况下要把整个链表都要读取一遍,节点一多就非常的耗时
epoll:没有限制 效率高 但是也有缺点:他是单线程的,一旦有一个线程在处理回调函数时非常耗时,别的事件就无法及时处理
单核cpu能用单线程就不要用多线程,因为假如你单核有两个线程,这两个线程也没法做到真正的并发,只是两个线程来回的循环交替,这还不如单线程,因为线程与线程的切换也需要时间
再严谨一点,因为硬件技术的进步,现在一般的处理器他一核就能模拟出两个逻辑核心,
所以,一般电脑硬件能有几个逻辑核心就开几个线程是效率最大的,
以前单核cpu只能处理一个线程,现在可以处理两个.


升级 -> 1.epoll+多线程 2.libevent+多线程
多线程的缺点:在单核cpu下,多线程无法发挥并发的优势,那也是线程来回交替

libevent+线程池: 实现原理:服务器在启动的时候,我先启动三个线程(假如说我是四核cpu且硬件单核只能模拟出一个逻辑核心),先放在一边,
来任务之后,挨个往这个空闲的线程里面分配
伪代码:
//1.服务器本身就是1个线程 ,又叫主线程和监听线程
//2.libevent本身就是一个循环,监听这个事件集合,哪个集合有事自己跳出来
//3.我们给每个线程都放一个事件集合base,也就是说这3个线程再同时监听这个base
(为什么不能让这些线程共用一个事件集合?
这涉及到线程竞争的一个问题,要防止线程同时访问这个集合)


